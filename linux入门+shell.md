## linux入门

#### 1.路径描述

1).绝对路径：
从根目录开始描述
如：/home/xxx/xxx 其中，pwd就是一个绝对路径
2).相对路径：
从当前路径开始去描述一个路径
如：tmp/main.cpp
3).判别方法：绝对路径的开头一定是 / 而相对路径的开头一定不是斜杠
4)
. 一个点表示当前路径
..两个点表示上一个目录
~/ 家目录
/根目录

#### 2.常用命令

1).ctrl+c 取消命令，并且执行换行指令
也可以杀掉程序

2).ctrl+u 清空本行

3).tab 补全一个命令/路径/文件
如果系统发现只有一种方案就会补全，
如：homew——
如果有多种方案则不补全
在这种情况下，按两下tab键有可接可选

4).↑ 展示上一条命令

5).ls:展示列表内容
其中：
蓝色 文件夹
白色 普通文件
绿色 可执行文件
1>.常用参数
-l 每一个文件的详细信息
-h 人性化输出（也就是让数据好看)
-a 显示隐藏文件
.a.txt ,以点为开头的，都是隐藏文件,当去掉点，变为可见文件
-A 不显示当前目录和上层目录
2>.几个权限
d 文件夹

- 普通文件
r,w,x读、写、执行

6).pwd 显示当前路径

7).cd 切换文件目录
不加参数默认返回家目录
cd .. 返回上一层
cd - 返回上一层呆过的目录

8).cp:复制命令
cp a/tmp.txt b
将a种文件复制到b文件夹
cp a.txt a.txt.bak
将该文件复制成a.txt.bak
cp=复制+粘贴+重命名
复制目录：cp a b -r
注：当命名中有空格可用\转义
将a整个复制到当前目录
cp a. / 或 cp a -

9).mkdir 创建文件夹
可以持续创建，即
mkdir a/b/c -p

10).rm删除操作
可以多个删除，也可以支持正则表达式
rm c -r 删除文件夹
rm *.txt 删除全部txt文件，其中*指文件夹中所有文件
-f 删除被保护的文件
rm a/*删除文件夹中的东西
rm /* -rf w勿试！！！！

11).mv可实现：剪切+粘贴/拖拽/重命名/移动
mv tmp.txt tmp.txt 也就是只重命名

12).cat展示文件中的内容
只能展示一个文件，不能多个展示
touch 创建文件

#### vim教程

功能：
    (1) 命令行模式下的文本编辑器。
    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。
    (3) 使用方式：vim filename
        如果已有该文件，则打开它。
        如果没有该文件，则打开个一个新的文件，并命名为filename
模式：
    (1) 一般命令模式
        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。
    (2) 编辑模式
        在一般命令模式里按下i，会进入编辑模式。
        按下ESC会退出编辑模式，返回到一般命令模式。
    (3) 命令行模式
        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。
        可以查找、替换、保存、退出、配置编辑器等。
操作：
    (1) i：进入编辑模式
    (2) ESC：进入一般命令模式
    (3) h 或 左箭头键：光标向左移动一个字符
    (4) j 或 向下箭头：光标向下移动一个字符
    (5) k 或 向上箭头：光标向上移动一个字符
    (6) l 或 向右箭头：光标向右移动一个字符
    (7) n<Space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符
    (8) 0 或 功能键[Home]：光标移动到本行开头
    (9) $ 或 功能键[End]：光标移动到本行末尾
    (10) G：光标移动到最后一行
    (11) :n 或 nG：n为数字，光标移动到第n行
    (12) gg：光标移动到第一行，相当于1G
    (13) n<Enter>：n为数字，光标向下移动n行
    (14) /word：向光标之下寻找第一个值为word的字符串。
    (15) ?word：向光标之上寻找第一个值为word的字符串。
    (16) n：重复前一个查找操作
    (17) N：反向重复前一个查找操作
    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2
    (19) :1,$s/word1/word2/g：将全文的word1替换为word2
    (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。
    (21) v：选中文本
    (22) d：删除选中的文本
    (23) dd: 删除当前行
    (24) y：复制选中的文本
    (25) yy: 复制当前行
    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴
    (27) u：撤销
    (28) Ctrl + r：取消撤销
    (29) 大于号 >：将选中的文本整体向右缩进一次
    (30) 小于号 <：将选中的文本整体向左缩进一次
    (31) :w 保存
    (32) :w! 强制保存
    (33) :q 退出
    (34) :q! 强制退出
    (35) :wq 保存并退出
    (36) :set paste 设置成粘贴模式，取消代码自动缩进
    (37) :set nopaste 取消粘贴模式，开启代码自动缩进
    (38) :set nu 显示行号
    (39) :set nonu 隐藏行号
    (40) gg=G：将全文代码格式化
    (41) :noh 关闭查找关键词高亮
    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令
异常处理：
    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。
    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：
        (1) 找到正在打开该文件的程序，并退出
        (2) 直接删掉该swp文件即可

### shell

###### shell语法的内容相对较多且杂碎难记，因此需要整理一下，现将shell的一些基本语法整理如下

注释
1.# 单行注释
2.多行注释 (一般不常用),且EOF可以被任何字符所替换

```
: <<EOF 
{ 注释内容
EOF
```

3.！也可以用作注释

变量
1.定义变量:
变量一般是以字符串的形式来定义，不需要加$号，常见的变量定义有以下几种方式

name="yxc"  # 双引号定义字符串
name='yxc'  # 单引号定义字符串
name=yxc    # 不加任何的符号定义字符串
2.使用变量:
在使用变量时，加$或${},{}是可选的，主要是用来帮助解释器识别变量边界(个人推荐加花括号)
如：

echo $name
echo ${name}
3.只读变量
 类似于c++中的 const变量，使用readonly与declare可以设置为只读变量
readonly name
declare -r 变量名
注：使用type命令可以检查每个命令是什么类型的命令

4.删除变量
 使用unset可以实现删除变量
 **当一个变量如果不存在，则其值为空字符串**
5.变量类型
1).自定义变量(局部变量)
子进程不能访问的变量
定义:

local 变量名 变量值
2).环境变量(全局变量)
子进程可以访问的变量

3).自定义变量 环境变量的转化

自定义→环境
export 变量名
declare -x 变量名 (推荐)
环境→自定义
export 变量名
declare +x 变量名 (推荐)
4).如何开子进程
输入 bash
这样即可进入新的bash，原有的bash被睡眠掉
输入 exit即可退出

6.字符串
  字符串可以用单引号、双引号、也可以不用引号
  区别在于：
单引号:原样输出，不会执行、不会取变量
双引号:会转义、会取变量、会执行
不加引号与有双引号一样

1).获取字符串长度：
加#一般是取长度，变量或者数组，如下所示：

```
echo ${#name}
```

2).提取子串

```
echo ${name:0:5} # 提取从0开始的5个字符
```

默认变量
1.文件参数变量：
形如；$0 $1 $2 之类的称作执行文件名，当执行文件名达到两位数时，用{}括起来，以防止出现冲突
其中：
$0 :为文件名，也就是命令第一行

$1:第一个参数

2.其他的参数：

| 参数       | 说明                                                |
| ---------- | --------------------------------------------------- |
| $#         | 传入参数个数                                        |
| $*         | 返回所有参数,形如: $1 $2`` $3                       |
| $@         | 每个参数分别用双引号括起来的参数 "$1" "$2" "$3"     |
| $$         | 当前脚本运行进程id                                  |
| $?         | 上一条命令的退出状态，0表示正常退出，其他值表示错误 |
| $(command) | 返回命令的输出结构stdout，类似于cout等效于command   |


注：退出状态，即exit code 在c++语法中的return 0

数组
在shell中，数组支持不同类型值，但是只支持一维数组，下标从0开始

1.定义
可以用：小括号表示，元素之间用空格隔开

```
array=(1 abc "def")
```

或者如下的一种形式：直接定义数组中某个元素的值

```
array[0]=1
array[1]="abc"
array[2]=def
array[5]="yxc"   //取值下标可以跳着赋值，但数组长度与遍历方式不受影响
```

2.读取数组中某一元素的值:

```
${array[index]
```

3.读取整个数组的值:

```
${array[@]} # 写法一
${array[*]} # 写法二
```

4.读取数组长度

```
${#array[@]}
${#array[*]}
```

注：按照实际内容求长度

expr命令
expr命令本质上来说是一个bash命令，可以帮助做运算,其基本格式如下

```
expr 表达式
```

有几点需要注意：
1).每一项都用空格隔开
2).特殊字符用转义字符转义掉，报错加’'
3).包含空格/其他特殊字符时，需要用引号括起来

##### 4).expr一般会在stdout中输出，但如果为逻辑关系表达式，则当结果为真，stdout为1 ，否则为0，同时会在exit code中输出结果。此时，若为逻辑关系表达式，则结果为真，exit code为0，否则为1，若为其他表达式，exit code为9

1.字符输出
1).输出长度
基本格式为：

```
length 字符串
echo ${expr length "$str"}
echo `expr length str`
```

2).查询在字符串中，某个字符CHARSET最先出现的位置
如果在整个字符串中，该字符一直没有出现过，则输出结果为0
其格式如下：

```
index STRING CHARSET
```

3).返回从position开始，长度为length的字符串

```
substr STRING position length 
echo `expr substr "$str" 2 3`
```

2.整数表达式
一般来说，符号有：

```
+ - * / % ()
```

从运算上来看，整数表达式的优先级低于字符串高于逻辑关系表达式

3.逻辑表达式
逻辑表达式的符号有如下几种：

/
类似于c++中的//

&
类似于c++中的&

< <= = == != >= >
用作比较符号两端的参数，其具体操作规则为：先转整数，若失败，则按照字符串规则来判断

()
可以改变优先级，但需要用反斜杠来转义

短路原则：其基本规则如下：
若为a|b
当a不为0，则直接返回a，b不计算
当a为0，则直接返回第二个值，即b的值，若b为空串，返回0
若为a&b
当在a&b中有一个值为0，即为0，如果都不为0，即返回a的值，如果a是0，则不计算

read命令
用于读取单行数据读取到某个变量里，当读到文件结束符时，exit code 为1，否则结果为0
-p 后面可以接提示信息
-t 规定服务器等待时间，来响应结束该命令

echo命令
用于输出字符串,其基本格式如下：

```
echo STRING # STRING 的引号可以省略
```

1.显示转义字符

```
echo "\' Hello AC terminal "\'
echo \' Hello AC Terminal \'
```


可以省略掉双引号也可以用双引号，但是不能省略掉单引号

2.显示变量
$ 例：

```
name=abc
echo "My name is $name"
```

注：不要用单引号引，单引号不能读变量

3.显示换行吧
示例:

```
echo -e 'hello\n' # 单引号双引号都行，但是一定要加
echo "acwing"
```

-e开启转义

4.强行不换行
示例如下:

```
echo -e "Hi\c" 
```

\c取消掉回车，但是一定要用引号括起来!!!

5.结果重定向
echo默认是在command命令中，但是通过结果重定向也可以在文件里
其格式如下:

```
echo "hello world" > 文件名
```

6.原样输出字符串，不进行转义或取变量
将字符串用单引号引起来即为原样输出,如:

```
echo '$name\"'
```

7.输出命令的执行结果
通过使用`` 可以将标准输出截取并且返回

printf命令
基本上来讲于c/c++的一样，其基本语法格式为:

```
printf format-string [arguments...]
```

每一个语法符号之间是需要用空格来隔开，其他语法与c++一致

test命令与[]判断符号
test命令为一个shell内嵌命令，用于判断表达式是否为真

1.两个逻辑表达式:&&与||
与expr中的&和|不同的是，expr中的为自己定义的，该逻辑表达式为bash中自有的，其同样具有expr的逻辑表达式中的短路原则,其基本逻辑如下:
1 && 2 若1为假，则直接不做判断
1 || 2 若1为真，则直接不做判断
通过该逻辑表达式，可以实现if-else的作用

2.test用法:
主要是用于判断元素类型以及比较元素值(元素：特指整数和字符串)，一般是用exit code返回结果，而不是用stdout
凡是当:expr用stdout来输出结果，用1来表示真，0表示假
test用exit code 来输出结果，用0表示真，用1表示假

3.文件类型判断
符号	说明
-e	文件是否存在
-f	是否为文件
-d	是否为目录
4.文件权限判断
符号	说明
-f	文件是否可读
-w	文件是否可写
-x	文件是否可执行
-s	文件是否为非空文件
5.整数间比较
符号	说明
-eq	a=b
-ne	a是否不等于b
-gt	a是否大于b
-lt	a是否小于b
-ge	a是否大于等于b
-le	a是否小于等于b
6.字符串比较
符号	说明
-z	判断是否为空，为空则返回true
-n	判断是否非空
str1==str2	是否相等
str1!=str2	是否不等
7.多重判定
将与或非在一个判断中实现
-a 两条件是否同时成立
-0 两条件是否至少一个成立
! 取反，如test ! -x file,此时如果file不可执行时，返回true

8.判断符号[]
基本作用与test完全一样，甚至可以完全取代test,示例如下：

```
[ 2 -lt 3 ]
```

记得每一项用空格隔开，中括号中的变量，最好用双引号括起来，以防止歧义

判断语句
if判断语句的基本格式与c++的完全一致

1.单层if
基本格式

```
if condition
then
    语句1
    语句2
    ...
fi
```

注：condition可以是语句，用于判断退出状态是否为0，其返回的是一个表达式，而不是一个结果
condition可以使用expr来实现功能，具体编写的格式如下:

if expr 3 '>'3
2.if-else
基本格式:

```
if condition
then
    ...
else
   ....
fi
```

3.多组if-elif-elif-else
基本格式:

```
if condition
then
    语句1
    语句2
    ...
elif condition
then
    语句1
    语句2
elif condition
then
    ....
else
fi
```

4.case…case
类似于c++中的switch语句
基本格式:

```
case $变量名称 in
   值1)
    语句1
    语句2
    ...
    ;;
   值2)
    语句1
    语句2
    ....
    ;;
   *)
     语句1
     语句2
     ...
     ;;
esac
```

有以下几点需要注意:
1.;;对应c中的break，*对应c中的
2.最后一行esac可以删掉;;

循环语句
格式与基本用法基本上与c++类似

1.格式1—for循环

```
for ..in..do..done
```

示例如下：

```
for var in val1 val2 val3
do
   语句1
   语句2
done
```

in后面可以以命令的形式来写，命令也可以改成$()的形式
seq:可以返回一个序列

2.bash内嵌
基本格式为:

```
for i in {a...z}
do
echo $i
done
```

但此方法不能直接在终端中用

3.完全类似c++的格式

```
for ((...;...;...))
do 
done
```

详解：第一个位置：定义变量，第二个位置：判断，第三个位置：修改变量值

格式2-----while循环
其基本格式与c++一致

```
while condition
do
    语句1
    语句2
done
```

该程序中：ctrl+d文件结束符，ctrl+c 杀死进程

格式3------until…do…done循环
基本格式：

```
until condition
do
   语句1
   语句2
done
```

与其他的condition判断不同的是，当condition为真，结束循环，当condition为假时，循环不结束
该程序中：ctrl+d文件结束符，ctrl+c 杀死进程

格式4-------break命令
与c++不同的是，break不能跳出case语句，在shell中跳出case用;;

格式5-------continue语句
如下示例:输出1-10中的所有奇数

```
for((i=1;i<=10;i++))
do
   if [ 'expr $i%2' -eq 0 ]
   then
     continue
   fi
   echo $i
done
```

死循环处理
在AC terminal中，输入：ctrl+c，即可杀死进程，输入ps aux/tmp可以返回当前打开的所有进程
输入kill -q PID可以关掉进程

函数
函数类似于c/c++，但是其return为 exit code，取值为0-255，不写return默认返回为0，0为默认正常结束，
返回值通过$?
返回内容：用echo将内容输出到标准输出当中，通过 $()/`` ,来截取内容

1.不获取return/stdout
示例如下:

```
func(){
    name=yxc
    echo="hello $name"

}
func
```

在调用时不需要写括号，直接加函数名即可

2.获取return/stdout
此时在不写return时，默认为return 0

3.传递参数
类似于命令执行方式，写法为：

```
echo ${func n) # n为传参的个数
```

注：函数内的$0依旧是文件名，不是函数名

4.获取参数
与获取脚本中常数参数是一样的，不同的是$0是没有的

exit命令
使用exit命令用来退出当前shell进程，会返回当前的一个退出状态，退出状态用$?查看
默认状态值为0，退出状态为0-255的整数，0为成功，其他为失败

文件重定向
每一个进程在打开时，都是独立的进程，每个进程都默认打开了3个文件
stdin:标准输入，从命令行读取数据，文件描述符为0
stdout:标准输出，向命令行输出数据，文件描述符为1
stderr:标准错误输出，向命令行输出数据，文件描述符为2
将内容输出进文件的几种方式

符号	说明
command > file	将内容重定向到文件里
command < file	从文件读内容到终端里
command >> file	从file里追加内容
command n > file	重定向任意一个文件描述符
command n >> file	重定向完成后以追加方式往里写
也可以用 n >同时重定向输入输出，但一般用不到

引入外部脚本:
其基本格式为:

```
./filename/source filename
```

在引入文件时，只需要文件有可读权限即可